  # CPU buffer. (ImageFrame)
  input_stream: "input_video"

  # Output image with rendered results. (ImageFrame)
  output_stream: "output_video"


  # Throttles the images flowing downstream for flow control. It passes through
  # the very first incoming image unaltered, and waits for downstream nodes
  # (calculators and subgraphs) in the graph to finish their tasks before it
  # passes through another image. All images that come in while waiting are
  # dropped, limiting the number of in-flight images in most part of the graph to
  # 1. This prevents the downstream nodes from queuing up incoming images and data
  # excessively, which leads to increased latency and memory usage, unwanted in
  # real-time mobile applications. It also eliminates unnecessarily computation,
  # e.g., the output produced by a node may get dropped downstream if the
  # subsequent nodes are still busy processing previous inputs.
  node {
    calculator: "FlowLimiterCalculator"
    input_stream: "input_video"
    input_stream: "FINISHED:output_video"
    input_stream_info: {
      tag_index: "FINISHED"
      back_edge: true
    }
    output_stream: "throttled_input_video"
  }

  #####################################################



  # Resizes the input image into a tensor with a dimension desired by the model.
  node {
    calculator: "SwitchContainer"
    input_side_packet: "SELECT:model_selection"
    input_stream: "IMAGE:throttled_input_video"
    output_stream: "TENSORS:input_tensors"
    options: {
      [mediapipe.SwitchContainerOptions.ext] {
        select: 0
        contained_node: {
          calculator: "ImageToTensorCalculator"
          options: {
            [mediapipe.ImageToTensorCalculatorOptions.ext] {
              output_tensor_width: 256
              output_tensor_height: 256
              keep_aspect_ratio: false
              output_tensor_float_range {
                min: 0.0
                max: 1.0
              }
              border_mode: BORDER_ZERO
            }
          }
        }
        contained_node: {
          calculator: "ImageToTensorCalculator"
          options: {
            [mediapipe.ImageToTensorCalculatorOptions.ext] {
              output_tensor_width: 256
              output_tensor_height: 144
              keep_aspect_ratio: false
              output_tensor_float_range {
                min: 0.0
                max: 1.0
              }
              border_mode: BORDER_ZERO
            }
          }
        }
      }
    }
  }

  # Generates a single side packet containing a TensorFlow Lite op resolver that
  # supports custom ops needed by the model used in this graph.
  node {
    calculator: "TfLiteCustomOpResolverCalculator"
    output_side_packet: "OP_RESOLVER:op_resolver"
  }

  # Loads the selfie segmentation TF Lite model.
  node {
    calculator: "SelfieSegmentationModelLoader"
    input_side_packet: "MODEL_SELECTION:model_selection"
    output_side_packet: "MODEL:model"
  }

  # Runs model inference on CPU.
  node {
    calculator: "InferenceCalculator"
    input_stream: "TENSORS:input_tensors"
    output_stream: "TENSORS:output_tensors"
    input_side_packet: "MODEL:model"
    input_side_packet: "OP_RESOLVER:op_resolver"
    options: {
      [mediapipe.InferenceCalculatorOptions.ext] {
        delegate {
          xnnpack {}
        }
      }
    }
  }

  # Retrieves the size of the input image.
  node {
    calculator: "ImagePropertiesCalculator"
    input_stream: "IMAGE_CPU:throttled_input_video"
    output_stream: "SIZE:input_size"
  }

  # Processes the output tensors into a segmentation mask that has the same size
  # as the input image into the graph.
  node {
    calculator: "TensorsToSegmentationCalculator"
    input_stream: "TENSORS:output_tensors"
    input_stream: "OUTPUT_SIZE:input_size"
    output_stream: "MASK:new_mask_image"
    options: {
      [mediapipe.TensorsToSegmentationCalculatorOptions.ext] {
        activation: NONE
      }
    }
  }

## --------------------- Smoothing calculator addition ------------------------


  node {
    calculator: "SegmentationSmoothingCalculator"
    input_stream: "MASK:new_mask_image"
    input_stream: "MASK_PREVIOUS:old_mask"
    output_stream: "MASK_SMOOTHED:smooth_mask"
    options: {
      [mediapipe.SegmentationSmoothingCalculatorOptions.ext] {
        combine_with_previous_ratio: 0.0
      }
    }
  }


  # Caches the filtered segmentation mask, similar to above for the pose rect.
  node {
    calculator: "PreviousLoopbackCalculator"
    input_stream: "MAIN:new_mask_image"
    input_stream: "LOOP:smooth_mask"
    input_stream_info: {
      tag_index: "LOOP"
      back_edge: true
    }
    output_stream: "PREV_LOOP:old_mask"
  }



## --------------------- Smoothing calculator end ------------------------


## --------------------- Bilateral filter add ----------------------------


## --------------------- Bilateral filter end ----------------------------


  # Converts the incoming Image into the corresponding ImageFrame type.
  node: {
    calculator: "FromImageCalculator"
    input_stream: "IMAGE:bilateral_mask"
    output_stream: "IMAGE_CPU:segmentation_mask"
  }



  #####################################################


  node {
    calculator: "ToImageCalculator"
    input_stream: "IMAGE_CPU:segmentation_mask"
    output_stream: "IMAGE:output_video"
  }